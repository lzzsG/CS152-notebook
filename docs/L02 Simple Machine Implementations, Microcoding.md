---
layout: post
title: L02 Simple Machine Implementations, Microcoding
permalink: /02
description: "L02 Simple Machine Implementations, Microcoding"
nav_order: 2


---

# L02 Simple Machine Implementations, Microcoding

### 上节课内容回顾

1. **计算机架构不仅限于指令集和RTL**：
   - CS152课程涉及硬件和软件的交互，设计合适的抽象层。

2. **技术与应用塑造计算机架构**：
   - 历史为未来的设计提供了重要的经验教训，理解过往的技术演进有助于应对未来挑战。

3. **计算机架构的前130年：从巴贝奇到IBM 360**：
   - 计算机的发展从简单的计算器（无条件分支）转向完全可编程的机器。
   - 尤其是在二战期间（1940年代中期），从机电设备到纯电子处理器的快速变革奠定了现代计算机的基础。

4. **软件开发成本成为架构设计中的重要制约因素**：
   - 软件的兼容性需求极大地影响了架构设计，确保新技术能够与现有系统兼容以减少开发成本和时间。



### 指令集架构（ISA）

- **定义**：ISA是硬件与软件之间的契约，通过描述所有程序员可见的状态（如寄存器和内存）以及操作该状态的指令的语义，定义计算机的操作方式。
  
- **作用**：ISA为程序员提供一个抽象层，使得同一套指令可以在不同的硬件实现上运行。它本质上是机器语言的规范，定义了计算机能执行的指令。

- **历史**：IBM 360是第一代将指令集架构与其具体实现（微架构）分离的机器。

- **多种实现**：一个给定的ISA可以有不同的硬件实现。例如：
  - 苏联曾开发出与IBM 360代码兼容的克隆机器。
  - AMD、Intel和VIA的处理器都运行AMD64指令集。
  - 许多智能手机使用ARM指令集架构，由包括苹果、华为在内的多家公司进行实现。
  
- **课程中使用的ISA**：我们在课程中使用RISC-V作为标准的指令集架构，许多公司和开源项目都构建了基于RISC-V的实现。

### 指令集到微架构的映射

- **设计风格与微架构的关系**：ISA通常是针对特定的微架构风格进行设计的。例如：
  - **累加器架构**：硬连线、无流水线设计。
  - **复杂指令集计算（CISC）**：微代码控制。
  - **精简指令集计算（RISC）**：硬连线、流水线设计。
  - **超长指令字（VLIW）**：固定延迟、顺序执行的并行流水线。

- **灵活实现**：尽管每种ISA都有典型的微架构风格，但它们可以用任何微架构风格来实现。例如：
  - Intel Ivy Bridge：硬连线流水线CISC（x86）机器，带部分微代码支持。
  - Apple M1：原生ARM ISA，但可以在软件中仿真x86。
  - Spike：软件解释的RISC-V机器。
  
- 本讲将讨论一种微代码控制的RISC-V机器。



### 为什么学习微程序设计？

微程序设计是计算机架构中的重要概念，特别是在处理复杂指令集（ISA）时。学习微程序设计有以下几个原因：

- **构建小型处理器**：微程序设计展示了如何在复杂指令集下构建非常小的处理器。通过微程序控制器，能够有效地管理复杂指令的执行，而无需庞大的硬件电路。
  
- **理解CISC机器的起源**：通过学习微程序设计，能够深入了解复杂指令集计算机（CISC）的起源及其设计理念。CISC机器以较少的指令数实现更多的功能，但每条指令可能更复杂且执行时间较长。

- **现实中的应用**：微程序设计仍然被广泛应用在常见的计算机中，例如x86架构的处理器、IBM 360系列、PowerPC等。

- **机器结构入门**：微程序设计为理解机器结构提供了一个温和的入门路径。通过微程序的方式，复杂指令的执行流程变得更加清晰易懂，降低了设计难度。

- **技术驱动的变革**：通过学习微程序设计，能更好地理解技术如何推动了从CISC向精简指令集计算机（RISC）的转变。RISC架构是对复杂指令集的一种简化，其理念是用更简单、更快速的指令来提高处理器的性能。

值得注意的是，CISC和RISC的名称比它们所指的机器风格出现得要晚得多，早期的机器设计并没有明确的“CISC”和“RISC”分类。

### 控制器与数据路径

在处理器设计中，控制器与数据路径的区分是非常关键的概念。处理器的设计通常可以分为数据路径和控制器两个部分。

- **数据路径**：数据路径负责存储数据并执行算术运算。它包括：
  - **寄存器**：存储操作数和结果的地方。
  - **算术逻辑单元（ALU）**：进行算术和逻辑运算的部件。
  - **程序计数器（PC）**：跟踪当前执行的指令地址。
  - **指令寄存器（Inst. Reg.）**：保存当前正在执行的指令。

- **控制器**：控制器的作用是对数据路径中的各个操作进行时序控制。它决定何时从寄存器中取数、何时开始执行ALU运算、何时存储结果等。控制器的设计是处理器设计中的一个重要挑战，尤其是在早期计算机设计中，如何正确设计控制电路成为了计算机设计者面临的最大难题。

- **微程序控制器**：Maurice Wilkes在1958年发明了微程序设计的思想，用于设计EDSAC-II处理器的控制单元。这一设计概念帮助解决了复杂控制电路的问题，将控制逻辑简化为可编程的微指令序列。Wilkes的想法受到了Babbage早期设计中的“Barrel”机制的启发，这一设计理念也出现在早期的可编程计算机中。

通过理解控制器与数据路径的关系，可以更好地设计和优化计算机的工作流程。





### 微程序控制的CPU架构

微程序控制的CPU是一种通过使用微代码（microcode）来实现复杂指令执行的处理器架构。其核心部分由控制器和数据路径组成，具体架构如图所示：

1. **主存储器（Main Memory）**：
   - 存储由宏指令编写的用户程序（如x86、RISC-V的指令）。
   - 宏指令通过地址和数据线传送到处理器中。
   
2. **数据路径（Datapath）**：
   - 数据路径是处理器的核心执行单元，负责执行算术逻辑运算（ALU），并处理寄存器之间的数据交换。
   
3. **微程序计数器（μPC）**：
   - 用于跟踪当前微指令的执行位置，每一条宏指令由多条微指令来分步完成。
   
4. **解码器（Decoder）**：
   - 解码宏指令并通过微程序计数器将控制信号传递到微代码存储器。
   
5. **微代码ROM（Microcode ROM）**：
   - 保存处理器执行微指令的固定存储区域。微指令规定了如何一步步完成复杂指令的执行。
   - 微代码ROM通过控制线将信号传送给数据路径，指挥数据的处理过程。

6. **控制信号（Control Lines）**：
   - 微代码ROM产生的信号控制数据路径内的各个模块（如寄存器、ALU）的操作。

通过这种微程序控制架构，复杂的指令集可以被拆分为一系列更简单的微指令，以此来简化硬件设计并提高指令执行的灵活性。

### 技术影响

微代码设计的出现始于20世纪50年代，当时的硬件技术条件与今天大不相同，各种存储和逻辑实现手段在设计中扮演了重要角色。

- **逻辑元件**：当时的逻辑单元主要依赖于**真空管**。
- **主存储器**：采用的是**磁芯存储**，其存取速度和容量都受到了限制。
- **只读存储器（ROM）**：使用了**二极管矩阵**或**穿孔金属卡片**来实现。这些技术虽然原始，但可以高效地存储和访问微代码。

此外，几项技术特点对微代码的广泛应用产生了深远影响：

1. **逻辑电路昂贵**：相比只读存储器（ROM）或随机存取存储器（RAM），使用逻辑电路的成本高得多。因此，将复杂指令的控制逻辑转移到更便宜的微代码中成为一种高效的解决方案。

2. **ROM比RAM便宜**：当时的存储技术限制使得ROM比RAM更经济，因此使用ROM来存储微指令是一种可行的选择。

3. **ROM速度远快于RAM**：由于ROM的读取速度较快，微程序设计能够在不损失性能的前提下减少硬件复杂度，从而提高了整体系统的效率。

这些技术背景解释了微程序设计为何在当时成为复杂指令集处理器（如x86、IBM360）的主流设计选择。





### RISC-V 指令集架构 (ISA)

RISC-V 是由加州大学伯克利分校开发的第五代精简指令集（RISC）设计，具有现实性和完整性，同时保持开放和小巧的特性。以下是 RISC-V ISA 的一些关键特点：

- **开放性与灵活性**：RISC-V 是一种开放标准，不与特定的实现风格绑定，支持广泛的硬件实现。
- **32位与64位架构**：支持 32 位（RV32）和 64 位（RV64）地址空间，适用于多处理器系统。
- **高效的指令编码**：RISC-V 的指令集编码设计注重效率，使其适用于从嵌入式系统到高性能计算的各类应用。
- **扩展性强**：便于教育、科研和实际工程中进行子集化和扩展。
- **行业应用广泛**：RISC-V 正逐渐获得工业界的广泛采用，许多公司和开源项目正在基于 RISC-V 构建其处理器架构。

### RV32I 处理器状态

RV32I 是 RISC-V 的 32 位整数指令集变体，其处理器状态如下：

- **程序计数器 (pc)**：存储当前正在执行的指令的地址。
- **32 个 32 位整数寄存器（x0 - x31）**：
   - 寄存器 x0 固定为 0，不能被更改，用于指令中的常数 0。
- **32 个浮点寄存器（f0 - f31）**：
   - 每个浮点寄存器可以存储单精度或双精度浮点数（32 位或 64 位的 IEEE 浮点数）。
- **浮点状态寄存器 (fcsr)**：用于浮点操作的四舍五入模式和异常报告。

在处理器内部，整数寄存器和浮点寄存器分别用于处理整数运算和浮点运算。浮点寄存器的使用通常与高精度科学计算和多媒体处理相关联。





### RISC-V 指令编码 (Instruction Encoding)

RISC-V 指令集架构 (ISA) 支持可变长度的指令格式，以灵活适应不同的系统需求。以下是 RISC-V 指令编码的关键点：

- **可变长度指令**：RISC-V 支持从 16 位到 192 位及以上的指令长度，其中 32 位是最常见的基本指令长度。
- **固定的 32 位基本指令集**：RV32 指令集总是使用 32 位的指令，且其最低两位固定为 11₂，用于标识基本指令。
- **分支与跳转指令的目标**：所有分支与跳转指令的目标地址以 16 位为单位，尽管基本指令是 32 位长度，但这种设计优化了程序的分支处理。

### RISC-V 指令格式 (Instruction Formats)

RISC-V 使用几种不同的指令格式，主要包括 R 型、I 型、S 型、B 型、U 型和 J 型，每种格式适应不同的指令功能需求。以下是不同指令格式的基本组成部分：

- **R 型 (Register-Register Format)**：
  - `opcode` (7 bits): 操作码，指令类型。
  - `rd` (5 bits): 目标寄存器。
  - `funct3` (3 bits): 功能码，用于区分不同的操作。
  - `rs1`, `rs2` (5 bits): 源寄存器。
  - `funct7` (7 bits): 额外的功能码，进一步区分指令。
  
- **I 型 (Immediate Format)**：
  - `opcode` (7 bits): 操作码，指令类型。
  - `rd` (5 bits): 目标寄存器。
  - `funct3` (3 bits): 功能码。
  - `rs1` (5 bits): 源寄存器。
  - `imm[11:0]` (12 bits): 立即数，用于立即数操作指令。

- **S 型 (Store Format)**：
  - `opcode` (7 bits): 操作码，指令类型。
  - `imm[11:5]` (7 bits) 和 `imm[4:0]` (5 bits): 立即数部分，用于存储地址计算。
  - `rs1`, `rs2` (5 bits): 源寄存器。
  - `funct3` (3 bits): 功能码。

- **B 型 (Branch Format)**：
  - `opcode` (7 bits): 操作码。
  - `imm[12|10:5]`, `imm[4:1]`, `imm[11]`, `imm[20]` (13 bits): 分支地址的立即数。
  - `rs1`, `rs2` (5 bits): 源寄存器。
  - `funct3` (3 bits): 功能码。

- **U 型 (Upper Immediate Format)**：
  - `opcode` (7 bits): 操作码。
  - `rd` (5 bits): 目标寄存器。
  - `imm[31:12]` (20 bits): 高位立即数。

- **J 型 (Jump Format)**：



### 单总线数据通路 (Single-Bus Datapath for Microcoded RISC-V)

在微代码控制的 RISC-V 处理器中，单总线数据通路设计简化了数据传输的路径，使处理器各个单元通过共享总线来执行各种操作。以下是单总线数据通路的关键组成部分：

- **指令寄存器 (Instruction Reg.)**：存储当前的指令。
- **寄存器文件 (Register RAM)**：存储通用寄存器，包括程序计数器 (PC) 和用于计算的数据寄存器。
- **立即数扩展 (Immediate)**：从指令中提取立即数，并通过立即数选择 (ImmSel) 控制其使用。
- **算术逻辑单元 (ALU)**：执行算术和逻辑运算，使用源寄存器 `rs1` 和 `rs2` 的数据进行计算。
- **主存储器 (Main Memory)**：在存储指令或数据时通过 `MemW` 控制数据写入，或通过 `MemEn` 控制数据读取。

#### 微指令 (Microinstructions)

微指令用寄存器传输形式表示，用于控制各单元的操作。例如：
- `MA := PC`：选择 PC 作为地址源，并设置控制信号 `RegSel = PC`，`RegW = 0`，`RegEn = 1`，`MALd = 1`，表明从 PC 取地址。
- `B := Reg[rs2]`：从源寄存器 `rs2` 读取数据，设置控制信号 `RegSel = rs2`，`RegW = 0`，`RegEn = 1`，`BLd = 1`，准备将数据送入 ALU。
- `Reg[rd] := A + B`：通过 ALU 执行加法操作，将结果写入目标寄存器 `rd`，设置 `ALUOp = Add`，`ALUEn = 1`，`RegSel = rd`，`RegW = 1`。

> 在单总线数据通路（Single-Bus Datapath）中，设计的核心思想是通过一个共享的总线来传递指令和数据。图中的每个符号和信号都对应着特定的功能，确保整个指令执行的每个步骤可以顺利完成。为了更好地理解，这里对图中涉及的寄存器、信号和控制信号进行详细讲解：
>
> ### 核心组件
> 1. **指令寄存器（Instruction Register, IR）**：
>    - 作用：存储从内存中读取的当前指令，负责保存当前正在执行的指令。
>    - 输入信号：从内存加载的指令。
>    - 输出信号：指令的操作码 (Opcode) 和立即数 (Immediate) 被传递给解码器和 ALU 等后续阶段进行处理。
>
> 2. **程序计数器（Program Counter, PC）**：
>    - 作用：保存当前指令的地址，同时用于计算下一条指令的地址。
>    - 输入信号：通常是当前 PC 值加上 4（在 RISC 架构中，大多数指令的长度为 4 个字节）。
>    - 输出信号：为指令地址提供到内存中，从而获取指令。
>
> 3. **寄存器堆（Register File）**：
>    - 作用：包含 32 个通用寄存器，用于存储操作数和计算结果。
>    - 输入信号：
>      - `rs1` 和 `rs2`：读取的两个源寄存器，分别用于 ALU 操作。
>      - `rd`：写入目标寄存器，存储 ALU 或内存操作的结果。
>    - 输出信号：
>      - `A` 和 `B`：分别输出寄存器 `rs1` 和 `rs2` 中的值，输入到 ALU。
>
> ### 控制信号和数据流向
> 1. **立即数选择器（ImmSel）**：
>    - 作用：用于选择指令中的立即数，特别是与 R 型（寄存器类型）、I 型（立即数类型）和 J 型（跳转类型）指令相关的操作。
>    - 输入信号：指令的立即数字段。
>    - 输出信号：选择正确的立即数送到 ALU 或其他需要的单元。
>
> 2. **寄存器选择器（RegSel）**：
>    - 作用：控制从寄存器堆读取的操作数，决定从寄存器 `rs1` 和 `rs2` 中读取的内容。
>    - 输入信号：`rs1`、`rs2`。
>    - 输出信号：将寄存器中的值传递到 ALU 或其他执行单元。
>
> 3. **寄存器写信号（RegW）**：
>    - 作用：当需要将运算结果写入寄存器时，该信号为 1，允许数据写入寄存器堆中的 `rd`。
>    - 控制：由控制器根据指令类型（如算术操作或内存加载操作）来决定是否写入寄存器。
>    
> 4. **立即数使能（ImmEn）**：
>    - 作用：决定是否使用立即数，特别是用于 ALU 或内存地址计算时，立即数和寄存器值的结合。
>    - 控制：当操作需要立即数时，此信号使能；否则从寄存器读取值。
>
> ### 数据路径和控制单元
> 1. **ALU 操作符（ALUOp）**：
>    - 作用：决定 ALU 执行的具体算术或逻辑操作，例如加法、减法、逻辑与、或等操作。
>    - 输入信号：来自指令寄存器的操作码。
>    - 输出信号：将结果发送回寄存器堆或者用于其他阶段如内存写入等。
>
> 2. **ALU 使能（ALUEn）**：
>    - 作用：决定 ALU 是否激活以执行操作，主要用于算术和逻辑运算。
>    - 控制：该信号为 1 时，ALU 执行当前指定的操作，并将结果传递到输出寄存器。
>
> 3. **ALU 数据选择（ALUSel）**：
>    - 作用：决定 ALU 的操作数来源，是从寄存器还是从立即数中选择操作数。
>    - 控制：通过信号控制是否选择来自 `rs1`、`rs2` 或者立即数。
>
> 4. **内存地址（MemAddr）**：
>    - 作用：用于访问内存的地址，通过寄存器和立即数计算得到，例如加载或存储数据时使用的地址。
>    - 输入信号：来自 ALU 的地址计算结果。
>
> 5. **内存加载（MemLd）**：
>    - 作用：决定是否从内存中加载数据，并将其写入到寄存器堆。
>    - 控制：当执行 `lw`（加载字）指令时，该信号使能。
>
> 6. **内存写（MemW）**：
>    - 作用：决定是否将寄存器中的数据写入到内存地址中。
>    - 控制：当执行 `sw`（存储字）指令时，该信号为 1，将寄存器的内容写入到指定的内存地址。
>
> 7. **寄存器写使能（RegEn）**：
>    - 作用：允许 ALU 或内存操作的结果写入寄存器堆中的指定寄存器 `rd`。
>    - 控制：该信号根据指令类型（如算术运算或者从内存加载操作）控制。
>
> ### 微代码操作中的例子：
> - **指令取指阶段**：`MA := PC`，程序计数器的值作为内存地址，通过 `PC := PC + 4` 递增程序计数器并读取下一条指令。
> - **ALU 运算**：`Reg[rd] := ALUOp(A, B)`，通过 ALU 的操作符 `ALUOp` 执行运算，将源操作数 `A` 和 `B` 相加并写入目标寄存器 `rd`。
> - **分支判断**：通过 `Condition` 信号决定是否满足条件跳转的要求，`if !ALUOp(A, B)` 不满足条件则继续顺序执行，否则进行跳转。
>
> 整个单总线数据通路通过一系列控制信号和数据选择信号的交互，确保了每一条指令可以被正确执行。通过寄存器堆、ALU、内存以及各种控制信号的协调，处理器能够执行多种复杂的指令，并且在每个周期中能够完成一条指令的所有步骤。这些控制信号和路径共同确保了从指令取指到执行再到结果写回寄存器的顺利完成。
>
> > 要实现一个复杂的流程，通常涉及多条指令的连续执行，涵盖了各种操作类型，如加载数据、算术运算、分支跳转等。这里以一个较为复杂的场景为例，来说明如何在单总线数据通路（Single-Bus Datapath）中通过微代码和控制信号来执行一组指令操作。
> >
> > 假设我们要实现如下的操作流程：
> > 1. 从内存中加载两个操作数到寄存器中（`lw` 操作）
> > 2. 对这两个操作数进行加法运算（`add` 操作）
> > 3. 将结果存入另一个寄存器
> > 4. 判断结果是否为零，若为零则跳转到某个特定地址（分支跳转，`beq` 操作）
> > 5. 若不为零，则将结果写回内存（`sw` 操作）
> >
> > ### 具体指令流程：
> > 1. `lw x1, 0(x2)`：从内存地址 `x2` 处加载一个字到寄存器 `x1`。
> > 2. `lw x3, 4(x2)`：从内存地址 `x2 + 4` 处加载一个字到寄存器 `x3`。
> > 3. `add x4, x1, x3`：将寄存器 `x1` 和 `x3` 中的值相加，结果存入寄存器 `x4`。
> > 4. `beq x4, x0, label`：若 `x4` 的值为零，则跳转到 `label` 处。
> > 5. `sw x4, 8(x2)`：将寄存器 `x4` 的值存入内存地址 `x2 + 8` 处。
> >
> > ### 流程分解与微代码实现
> > 我们将上面的指令逐步分解为单个微操作，并且解释每个阶段如何控制单总线数据通路的各个信号来实现指令执行。
> >
> > #### 指令 1：`lw x1, 0(x2)` (加载内存内容到寄存器 `x1`)
> > 1. **指令取指**：
> >    - `MA := PC`，将程序计数器 `PC` 的值作为内存地址，去内存中读取指令。
> >    - `PC := PC + 4`，程序计数器加 4，以便读取下一条指令。
> >    - **信号**：`RegSel=PC`，`RegEn=1`，`MemLd=1`，`InstLd=1`。
> >
> > 2. **指令解码**：
> >    - 读取的指令是 `lw x1, 0(x2)`，立即数为 0，`rs1 = x2`，目标寄存器为 `rd = x1`。
> >    - **信号**：`ImmEn=1`，`ImmSel=0`（选择 0 作为立即数）。
> >
> > 3. **内存地址计算**：
> >    - 通过 `A := Reg[x2]` 从寄存器 `x2` 中读取基址，将 `A + 0` 作为内存地址。
> >    - **信号**：`ALUOp=Add`，`ALUEn=1`。
> >
> > 4. **内存访问**：
> >    - 通过计算出的内存地址，读取内存内容并将其存入目标寄存器 `x1`。
> >    - **信号**：`MemLd=1`，`RegSel=rd`，`RegW=1`。
> >
> > #### 指令 2：`lw x3, 4(x2)`（加载另一个内存内容到寄存器 `x3`）
> > 1. **指令取指**：
> >    - 类似上一条指令，PC 已经加 4，现在继续从内存中取指。
> >    - **信号**：同上。
> >
> > 2. **内存地址计算**：
> >    - 基址仍然是寄存器 `x2`，但立即数变为 `4`，因此内存地址为 `x2 + 4`。
> >    - **信号**：`ImmSel=4`，`ImmEn=1`，`ALUOp=Add`，`ALUEn=1`。
> >
> > 3. **内存访问**：
> >    - 将 `x2 + 4` 处的内存内容加载到寄存器 `x3` 中。
> >    - **信号**：同上。
> >
> > #### 指令 3：`add x4, x1, x3`（寄存器相加）
> > 1. **指令取指**：
> >    - 继续从 PC 处取指。
> >    - **信号**：同上。
> >
> > 2. **寄存器操作**：
> >    - 从寄存器 `x1` 和 `x3` 中读取操作数，并将结果存入寄存器 `x4`。
> >    - **信号**：`RegSel=rs1`（选择 `x1`），`ALUOp=Add`，`ALUEn=1`，`RegSel=rd`，`RegW=1`。
> >
> > #### 指令 4：`beq x4, x0, label`（条件分支）
> > 1. **指令取指**：
> >    - 取出分支指令。
> >    - **信号**：同上。
> >
> > 2. **比较运算**：
> >    - 比较 `x4` 和 `x0`（即零寄存器），若相等则跳转。
> >    - **信号**：`ALUOp=Sub`，`ALUEn=1`，`Condition=1`。
> >
> > 3. **跳转计算**：
> >    - 若比较结果为真，PC 更新为 `label` 的地址。
> >    - **信号**：`PC := PC + Imm`（跳转偏移量）。
> >
> > #### 指令 5：`sw x4, 8(x2)`（存储寄存器值到内存）
> > 1. **指令取指**：
> >    - 取出存储指令。
> >    - **信号**：同上。
> >
> > 2. **地址计算**：
> >    - 计算内存地址：`x2 + 8`。
> >    - **信号**：`ImmSel=8`，`ImmEn=1`，`ALUOp=Add`，`ALUEn=1`。
> >
> > 3. **内存写操作**：
> >    - 将寄存器 `x4` 的值写入到 `x2 + 8` 的内存地址中。
> >    - **信号**：`MemW=1`。
> >
> > ### 关键信号总结：
> > - **指令取指阶段**：`MA := PC`，`PC := PC + 4`，`MemLd = 1` 用于从内存读取指令，`InstLd = 1` 更新指令寄存器。
> > - **立即数选择（ImmSel, ImmEn）**：根据指令类型从立即数字段中选择合适的立即数，例如 I 型和 S 型指令中选择不同的立即数偏移。
> > - **ALU 运算控制（ALUOp, ALUEn）**：根据指令操作执行加法、减法、比较等运算。
> > - **内存操作（MemLd, MemW）**：决定是进行内存加载还是写回操作。
> > - **寄存器读写（RegSel, RegW）**：选择操作数寄存器，并在需要时将运算结果写入目标寄存器。
> >
> > ### 复杂流程中协调控制：
> > 在这个复杂流程中，控制信号的协调是至关重要的。控制单元需要根据每条指令的不同类型，适时激活各个控制信号，并确保指令执行的正确性。例如在跳转指令 `beq` 中，控制单元必须根据比较结果来判断是否更新 `PC`，而在加载和存储指令中，则需要确保正确的内存地址计算和数据读写操作。
> >
> > 通过这种微代码控制流程，单总线数据通路可以实现多种复杂的指令组合，确保从内存加载、寄存器操作、条件跳转到内存写回等操作都能有效地协同工作。



### RISC-V 指令执行阶段 (Instruction Execution Phases)

指令的执行过程可以划分为多个阶段，以下是 RISC-V 的基本指令执行流程：

1. **取指 (Instruction Fetch)**：从程序计数器指定的内存地址中读取指令。
2. **指令解码 (Instruction Decode)**：解析取出的指令，确定操作类型、源寄存器、目标寄存器等。
3. **寄存器取值 (Register Fetch)**：从寄存器文件中读取源操作数。
4. **ALU 操作 (ALU Operations)**：根据指令类型执行算术或逻辑运算。
5. **可选的存储操作 (Optional Memory Operations)**：对于需要访问内存的指令，执行读或写操作。
6. **可选的寄存器写回 (Optional Register Writeback)**：将计算结果或从内存中读取的数据写回目标寄存器。
7. **计算下一条指令的地址 (Calculate Next Instruction Address)**：更新 PC，准备执行下一条指令。



### 微代码示例 (Microcode Sketches)

#### Instruction Fetch（取指）
- `MA, A := PC`：将程序计数器 (PC) 的值加载到地址寄存器 (MA) 和寄存器 A 中。
- `PC := A + 4`：更新程序计数器，将其指向下一条指令。
- `wait for memory`：等待从内存读取指令。
- `IR := Mem`：将内存中的指令加载到指令寄存器 (IR)。
- `dispatch on opcode`：根据操作码 (opcode) 分派指令。

#### ALU 指令
- `A := Reg[rs1]`：将源寄存器 `rs1` 的值加载到寄存器 A。
- `B := Reg[rs2]`：将源寄存器 `rs2` 的值加载到寄存器 B。
- `Reg[rd] := ALUOp(A, B)`：使用 ALU 执行操作，并将结果存储到目标寄存器 `rd`。
- `goto instruction fetch`：返回取指阶段，准备执行下一条指令。

#### ALUI（带立即数的 ALU 指令）
- `A := Reg[rs1]`：从 `rs1` 取值。
- `B := ImmI`：立即数扩展为 12 位，并加载到寄存器 B。
- `Reg[rd] := ALUOp(A, B)`：执行 ALU 操作，将结果写入 `rd`。
- `goto instruction fetch`：返回取指阶段。

### 微代码示例 (2)

#### LW（Load Word）
- `A := Reg[rs1]`：从 `rs1` 取值。
- `B := ImmI`：符号扩展 12 位立即数，加载到寄存器 B。
- `MA := A + B`：计算内存地址，将 A 和 B 的和存储在地址寄存器 (MA) 中。
- `wait for memory`：等待内存数据。
- `Reg[rd] := Mem`：将从内存加载的数据存入目标寄存器 `rd`。
- `goto instruction fetch`：返回取指阶段。

#### JAL（Jump and Link）
- `Reg[rd] := A`：将返回地址存储在目标寄存器 `rd` 中 (PC 从取指阶段已经存入 A)。
- `A := A - 4`：恢复 PC，PC 已在取指阶段递增。
- `B := ImmJ`：将跳转类型的立即数加载到寄存器 B。
- `PC := A + B`：计算跳转目标地址，更新 PC。
- `goto instruction fetch`：跳转完成，准备执行下一条指令。

#### Branch（条件跳转）
- `A := Reg[rs1]`：从 `rs1` 取值。
- `B := Reg[rs2]`：从 `rs2` 取值。
- `if (!ALUOp(A, B)) goto instruction fetch`：如果 ALU 比较结果为假，跳到下一条指令（未跳转）。
- `A := PC`：如果条件满足，继续执行跳转操作，将当前 PC 存入 A。
- `A := A - 4`：恢复 PC（因为已经递增）。
- `B := ImmB`：将分支型立即数加载到寄存器 B。
- `PC := A + B`：计算分支目标地址并更新 PC。
- `goto instruction fetch`：返回取指阶段。



