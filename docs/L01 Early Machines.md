---
layout: post
title: L01 Early Machines
permalink: /01
description: "L01 Early Machines"
nav_order: 1

---

![image-20240906083635932]({{ site.baseurl }}/docs/assets/image-20240906083635932.png)

---

# L01 Introduction - Early Machines

## CS 152/CS252A 

## 计算机体系结构与工程/研究生计算机体系结构

## 课程简介

**课程**：CS152 计算机体系结构与工程  
**教授**：Sophia Shao，来自加州大学伯克利分校电气工程与计算机科学系。

### 计算机体系结构简介

计算机体系结构的核心任务是设计抽象层，这些抽象层允许我们利用现有的制造技术，高效地实现信息处理应用。计算机体系结构的定义涉及如何在**物理**与**应用**之间创建合理的桥梁。

在现代计算系统中，物理层和应用层之间存在较大的差距，无法直接跨越。因此，需要通过多个抽象层次逐步过渡，以有效构建复杂的计算系统。例如，物理现象（如电信号）经过电路和逻辑门处理，最终实现高级的应用程序。计算机体系结构在这些不同层次之间起着至关重要的作用。

### 现代系统中的抽象层次

在当今的计算系统中，抽象层帮助将复杂的物理设备转变为能够运行复杂应用的软件平台。以下是系统中典型的抽象层次：

<div style="display: flex; align-items: center;">
  <div style="flex: 40%;">
<ol>
    <li><strong>应用层</strong></li>
    <li><strong>算法层</strong></li>
    <li><strong>编程语言层</strong></li>
    <li><strong>操作系统/虚拟机层</strong></li>
    <li><strong>指令集架构（ISA）</strong></li>
    <li><strong>微架构</strong></li>
    <li><strong>寄存器传输级（RTL）</strong></li>
    <li><strong>电路层</strong></li>
    <li><strong>设备层</strong></li>
    <li><strong>物理层</strong></li>
</ol>
  </div>
  <div style="flex: 60%;">

<img src="{{ site.baseurl }}/docs/assets/QQ_1725583971686.png" alt="QQ_1725583971686" style="zoom:70%;" />
</div>
</div>

这些层次为现代计算机从物理硬件到应用程序的实现提供了结构化的方法，促进了计算机系统的设计与开发。每个层次在具体实现上都有自己的复杂性与挑战，而计算机体系结构课程主要聚焦于**指令集架构**、**微架构**和**RTL**层次的设计与优化。

## 计算设备的发展

1949年，剑桥大学设计并建造了世界上早期的电子计算机之一——**EDSAC**。相比现代计算设备，早期计算机体积庞大，计算能力有限，但其结构和设计理念为现代计算机的出现奠定了基础。通过不断改进和创新，现代计算设备已经能够处理极其复杂的任务。

### 现代计算设备
如今，计算设备已无处不在，广泛应用于不同的领域和设备中，如：
- **智能手机**（Smartphones）
- **笔记本电脑**（Laptops）
- **超级计算机**（Supercomputers）
- **媒体播放器**（Media Players）
- **摄像机**（Cameras）
- **游戏设备**（Games）
- **路由器**（Routers）
- **传感器网络**（Sensor Nets）
- **自动驾驶汽车**（Automobiles）
- **服务器**（Servers）
- **机器人**（Robots）

这些设备展现了计算机技术的多样性，计算设备的核心设计（如处理器、存储和通信）逐渐适应这些不同应用的需求。

### 体系结构的不断变化
计算机体系结构处于持续演进的过程中。体系结构不仅受益于**技术进步**，还受到了新**应用需求**的推动。技术的进步使得能够实现新功能或更高效地运行现有应用，进而推动新应用的开发和普及。

这种双向作用推动了计算机体系结构的演进，而应用和技术之间的相互反馈提供了体系结构的持续发展资金。例如，应用的需求提出了对技术的改进建议，而技术进步则使新的应用成为可能。与此同时，**兼容性**也成为市场中的重要因素，因为软件开发成本高昂，保持与现有系统的兼容性能减少成本并促进技术的推广。

![image-20240906085729355]({{ site.baseurl }}/docs/assets/image-20240906085729355.png)

### 单线程处理器性能演变
单线程处理器的性能在过去40年中有了显著提升，正如下图中所展示的那样，基于40年单线程处理器的性能数据，处理器的性能呈现出指数级增长。其演变可以分为几个阶段：
- **1980-1986**：每年性能提升约22%
- **1986-2003**：性能增长速度最快，年增长率达到52%
- **2003-2011**：增长减缓，年增长率为23%
- **2011-2015之后**：性能增速进一步放缓到约2.5%每年

这种趋势体现了**摩尔定律**的逐渐失效以及工艺缩放面临的瓶颈，也表明了未来计算体系结构的挑战和方向。

![QQ_1725584343849]({{ site.baseurl }}/docs/assets/QQ_1725584343849.png)

### 技术代际演变
摩尔定律（Moore’s Law）预示着集成电路中晶体管数量每18个月翻一番，进而带来性能的提升。在过去的一个世纪里，计算技术的核心基础设施经历了多次技术代际演变：
- **机电继电器**（Electromechanical Relays）
- **真空管**（Vacuum Tubes）
- **双极晶体管**（Bipolar Transistors）
- **nMOS/pMOS技术**
- **CMOS工艺**

每一代技术都带来了更高效的计算能力，展现了技术迭代对推动计算机体系结构发展的重要性。然而，随着半导体工艺逐渐接近物理极限，未来的发展方向仍然充满不确定性。

### 计算机设计中的变革

在过去50年中，**摩尔定律**一直主导着计算机设计的发展，半导体技术的进步使得性能和能效持续提升，且无需对软件模型进行大幅度改变。然而，近年来技术进步逐渐放缓，导致一些重要变化的出现：
- **Dennard缩放**（电压缩放）已经终止，供应电压趋于恒定。
- **摩尔定律**（每个晶体管的成本/集成度提高）的终结。
- 目前**没有可替代CMOS技术的竞争性新技术**。
- **能效问题成为主要约束**，驱动了新的架构和计算模式的需求。

对于软件开发者来说，不再有“**免费午餐**”，他们必须考虑：
- **并行系统**：需要更好地利用多核和多线程。
- **异构系统**：充分利用不同类型的计算硬件，如CPU、GPU和FPGA等。

### 今日主导的目标系统

当前主流的计算目标系统可以分为以下几类：

1. **移动设备**（智能手机/平板电脑）：
   - 每年销售超过10亿部。
   - 市场主要由基于ARM架构的通用处理器系统芯片（SoC）主导。
   - 包含定制加速器（无线电、图像、视频、图形、音频、运动传感、安全等功能）。

2. **仓库规模计算机**（Warehouse-Scale Computers, WSCs）：
   - 每个数据中心拥有数十万个核心。
   - 市场主要由x86架构服务器芯片主导。
   - 云托管虚拟机、专用应用，GPU、FPGA和定制硬件正被广泛应用于加速工作负载。

3. **嵌入式计算**：
   - 网络基础设施、打印机、消费电子设备（电视、音乐播放器、游戏设备、相机等）。
   - 物联网（IoT）设备，包括智能家居、健康设备、可穿戴设备等。

### 新型纵向半导体业务模式

随着技术的进步，芯片客户（如苹果、三星、谷歌等）不再只是购买标准的芯片产品，而是开始定制化设计芯片以满足差异化的需求。例如：
- **手机领域**：苹果、三星、高通、华为等公司设计自家的SoC。
- **客户端/云端领域**：谷歌、亚马逊、阿里巴巴、微软为各自的云服务定制芯片。
- **汽车领域**：特斯拉、Cruize等为自动驾驶等应用设计专用芯片。
- **物联网与可穿戴设备**：Fitbit、苹果等公司针对智能手表和健康监控设备设计芯片。

这种模式的背后是为了提升产品的**最终价值**和**利润**，从而弥补芯片设计的巨额成本（通常超过1亿美元的研发费用）。企业通过定制芯片可以获得显著的性能和功能差异化，进而在市场中保持竞争优势。

### Apple M1 芯片



<div style="display: flex; align-items: center;">
  <div style="flex: 70%;">
<p>例如，Apple M1芯片是苹果基于ARM架构设计的专用处理器，集成了CPU、GPU、AI加速器等多个模块，代表了现代垂直整合模式下的典型芯片设计。</p>
  </div>
  <div style="flex: 30%;">

<img src="{{ site.baseurl }}/docs/assets/image-20240906090708415.png" alt="image-20240906090708415" style="zoom:50%;" />
</div>
</div>





## 课程安排（CS152/CS252A 2023春季学期）

## CS152/CS252A 联合安排
- CS152和CS252A课程将共享部分讲座，时间为每周二/四 12:30-2:00pm。对于CS252A的学生，某些初期讲座为复习材料，部分讲座可能仅限CS252A。
- 联合安排的两次期中考试分别在2月28日和4月6日进行，某些问题可能只针对CS152或CS252A的内容。
- CS152设有问题集（Problem Sets），鼓励CS252A学生也使用它们进行复习和自主学习。
- CS152实验室也对CS252A学生开放，可供自主学习。
- 讨论课将在下周开始，所有学生可以参与讨论。
- CS152的期末考试将在学期结束时进行。
- CS252A学生则有额外的阅读讨论课，以及课程项目。

## 教学团队
- **主讲教授**：Sophia Shao
- **助教团队**：
  - Animesh Agrawal（主助教）
  - Abraham Gonzalez
  - Allison Husain
  - Divija Hasteer
  - Edwin Lim
  - Jamie Hong
  - Prashanth Ganesh
  - Alex Hao（阅读助教）

## 成绩评定标准

### CS152 评分标准
- **问题集（15%）**：
  - 问题集用于帮助学生掌握材料，讨论是鼓励的，但必须独立提交答案。
  - 分数基于完成情况，考试假设学生已经完成了所有题目。
  - 在问题集提交后发布答案。

- **实验（25%）**：
  - 实验使用高级的架构模拟器，每个实验结合指导与开放式问题。
  - 至少完成三次实验，否则将自动得到F等级。

- **考试（60%）**：
  - 期中考试占15%+15%，期末考试占30%，共计60%。
  - 考试为闭卷形式，不允许使用计算器、手机、笔记本等设备。
  - 可以在期末考试时“击败”期中考试成绩。
  - 对于其他形式的评估，个别情况将单独处理。

### CS252A 评分标准
- **文献阅读（20%）**：
  - 学生需要阅读学术论文，并提交摘要和参与讨论。

- **考试（30%）**：
  - 两次期中考试各占15%，闭卷考试，不能使用电子设备。
  - 评估内容包括讲座、阅读材料、问题集和实验。

- **课程项目（50%）**：
  - 课程项目是一个实质性的研究项目，学生将分组完成，定期与教学团队见面。
  - 最终需提交10页左右的会议风格的论文，并进行课堂展示。

### CS152/CS252A 课程交叉安排

- **伯克利本科生不能参加CS252A**。
- **CS152学生可以参与CS252A的文献阅读讨论**，但无法提交回应。
- **CS152学生可以参与课程项目**，但不会被打分。
- **CS152学生可以参加CS252A的最终项目展示**。
- **CS252A学生可以完成CS152的问题集**，但不会被打分。
- **CS252A学生可以参加实验课程**，但不会被打分。
- **CS252A学生可以参加讨论课**。

### CS152 实验

- 每个实验包括指导部分和开放式的任务。
  - **指导部分（30%）**：确保学生理解实验背后的主要概念。
    - 每个学生必须独立完成实验，并提交实验报告。
  - **开放式任务（70%）**：鼓励学生展示创造力。
    - 例如，一天的小型项目，尝试新的架构想法并测量潜力，即使结果是否定的也可以。
    - 学生可以单独或组队完成开放任务（2-3人一组）。
    - 不同组的学生可以为不同的任务工作。

- 实验报告必须为**可读的英文总结**，不能只是日志文件的简单堆积。
  - 我们会奖励优秀的报告，惩罚难以理解的报告。

## RISC-V vs 经典ISA

- **RISC-V** 是一个全新的、简单的、干净的、可扩展的ISA（指令集架构），由伯克利为教育（包括课程61C/151/251A/152/252A）和研究（ParLab/ASPIRE/ADEPT/SLICE）开发。
  - 早期的伯克利RISC实现包括RISC-I/II，SOAR/SPUR等项目考虑了RISC-III/IV。
  - RISC-V相较于主流ISA（如x86和ARM）更简单，非常适合教学和研究。
  - **RISC-V** 已广泛应用于商业领域，由**RISC-V基金会**管理标准（见[riscv.org](https://riscv.org)）。

- **工具支持广泛**：包括gcc、Linux、FreeBSD等，已成为许多现代工具的标准。
- **应用领域**：
  - Nvidia在其未来的GPU中使用RISC-V。
  - Western Digital在未来的所有产品中使用RISC-V。
  - 三星、Qualcomm、Google等众多公司均有使用RISC-V。

## Chisel

- **Chisel** 是伯克利开发的一种新的硬件描述语言，基于Scala。

  Constructing Hardware in a Scala Embedded Language
- 实验将使用基于Chisel的RISC-V处理器模拟器，这些模拟器比其他工具提供了更详细的信息，并且可以映射到FPGA或真实芯片布局。
  - CS152学生需要学习一些基本的Chisel语言，但我们会提供**Chisel RTL源码**，让你可以看到所有设计细节。

- **实验项目选项**：

  - 你可以基于Chisel RTL代码修改并构建实验项目。

- 今年，实验将使用**Chipyard**基础设施：
  - 访问[Chipyard文档](https://chipyard.readthedocs.io/en/latest/)，以获取更多信息。

### Chisel设计流程

Chisel设计流程是硬件设计中的一个关键步骤，尤其是在FPGA和ASIC的开发中。它通过以下流程实现从设计描述到实际布局的转化：

1. **Chisel设计描述**：
   - 开始于Chisel语言编写的硬件设计描述。
2. **Chisel编译器**：
   - Chisel设计通过Chisel编译器编译为Verilog代码。Verilog是一个广泛使用的硬件描述语言。
3. **工具链分支**：
   - 编译后的Verilog代码可以输入到不同的工具链中：
     - **FPGA工具**：
       - 主要用于FPGA仿真和开发，包括FPGA的功能验证与部署。
     - **ASIC工具**：
       - 主要用于专用集成电路（ASIC）的设计，最终生成GDS布局，用于制造。

通过这个流程，设计者可以高效地从高级设计概念转换为具体的硬件实现。

## 计算机架构：历史回顾

在整个课程中，历史叙述将帮助我们理解某些设计思想的产生背景。这些旧的设计理念之所以重要，是因为它们提供了以下几点帮助：

- **解释设计过程**：它有助于说明设计过程中做出某些决定的原因。
- **未来技术的约束**：未来的技术可能会面临与过去类似的约束，理解历史有助于应对未来挑战。
- **避免重复历史错误**：忽视历史的人注定会重复历史的错误。主机设计中的错误在微型计算机中被重复，在微型计算机后又如何呢？

通过历史的视角，可以更好地理解设计中的权衡与选择。

## 模拟计算机

**模拟计算机**将问题变量表示为某种物理量（例如，机械位移或电容器上的电压），并利用经过缩放的物理行为来计算结果。这类计算机在早期计算中占据重要位置，用于解决物理现象中的复杂问题。

一些模拟计算机的实例包括：
- **安提凯希拉机械装置**：一种公元前100年左右的复杂机械装置，用于天文计算。
- **飞机尾部涡流实验**：现代风洞实验中，通过模拟物理气流行为研究飞机设计的涡流特性。

模拟设备展示了物理现象的复杂性如何通过模拟计算得到解释，在现代计算机发展之前，模拟计算是很多复杂计算问题的唯一选择。

## 数字计算机

数字计算机通过使用离散步骤对问题变量进行编码来表示问题。相比于模拟计算机，数字计算机具有以下优点：

- **离散步骤提供噪声抗性**：离散信号可以更好地抵御噪声的干扰，提供更加稳定的计算结果。
- **精确且确定的计算**：相同的输入能够精确地产生相同的输出，保证了结果的可重复性和确定性。
- **不受物理可实现函数的约束**：数字计算机的计算能力不限于物理系统中可实现的功能。
- **可编程的数字计算机是CS152/252A课程的重点**：现代数字计算机具有极强的灵活性，可以通过编程实现各种复杂的功能。

## 查尔斯·巴贝奇 (1791-1871)

查尔斯·巴贝奇被誉为计算机科学的先驱，他在数学和机械设计方面做出了重大贡献：

- **剑桥大学卢卡斯数学教授**（1828-1839）。
- **多才多艺的博学者**：巴贝奇对多个学科领域有着广泛的兴趣，尤其在数学、机械设计和表格计算等领域有重要贡献。
- **挑战错误的印刷表格**：巴贝奇因当时印刷表格中的错误感到挫败，立志设计机器来评估和打印精确的计算表。
- **受到早期手工计算者的启发**：他受到早期人类“计算者”手动计算表格的启发，开始着手设计可以替代人力进行复杂计算的机器。

## 差分机（1822）

差分机是查尔斯·巴贝奇设计的机械计算设备，目的是通过多项式近似连续函数：

差分机能够通过加法计算的原因主要归结于 **多项式差分法**。多项式函数的计算可以分解为一系列的 **差分**，而这些差分在每一步都可以用简单的加法操作来求得。这是差分机的核心原理。

### 差分的概念

考虑一个多项式函数，如：
\\[
f(n) = n^2 + n + 41
\\]

通过计算相邻项之间的差分，可以得到如下规律：

- **一阶差分**（\(d1(n)\)）表示函数相邻项之间的差：
  \\[
  d1(n) = f(n) - f(n-1) = 2n
  \\]
  这个公式表示通过计算当前项和前一项之间的差，可以得到一个新的函数 \(d1(n)\)。

- **二阶差分**（\(d2(n)\)）是对一阶差分再做一次差分：
  \\[
  d2(n) = d1(n) - d1(n-1) = 2
  \\]
  在这个例子中，二阶差分是一个常数 2。

### 用加法计算

通过上述差分公式，可以看出每一阶差分的计算只涉及 **加法操作**。这是因为：

1. **固定的二阶差分**：对于一个二次多项式来说，二阶差分是一个常数。因为每一步的变化是固定的，所以只需要不断将这个常数加到前一个结果上，就可以得到新的值。
   
2. **迭代过程中的加法**：从最低阶差分开始，通过不断将二阶差分加到一阶差分，再将一阶差分加到原始函数值，可以一步步推导出函数的值，而每一步都只涉及加法。

因此，巴贝奇的差分机只需要使用**加法器**，通过逐步迭代差分来近似计算多项式函数。这种方法避免了直接进行乘法或幂运算，使得计算过程更加简化和高效。

![image-20240906092601318]({{ site.baseurl }}/docs/assets/image-20240906092601318.png)

## 差分机的实现

虽然查尔斯·巴贝奇并未完全完成差分机的构建，但其设计理念对后续的机械计算机设计产生了深远影响：

- **机械计算器**：差分机采用手摇设计，使用十进制数字进行计算。
- **未完成的项目**：巴贝奇在完成差分机后期，开始转向分析机的设计，差分机的设计理念也部分应用于分析机的改进中。
- **Schuetz的完成工作**：1855年，Schuetz在瑞典完成了巴贝奇设计的差分机，并将其出售给英国政府。
- **现代复制**：如今，差分机的现代复制品展现在大英科学博物馆和美国圣何塞计算机历史博物馆中，展示了当时技术实现复杂设计的可能性。

这一设计不仅在机械设计领域具有开创性意义，也为现代计算机科学的发展奠定了理论基础。



## 分析机（Analytical Engine, 1837）

分析机被认为是**第一台通用数字计算机**，其设计包含多个版本，但都未完全建成。巴贝奇的设计预见了现代计算机的主要组成部分：

- **"存储器"**：主要内存用于保存数字和中间计算结果，能够存储1,000个十进制数字，每个数字长达40位。
- **"磨坊"（Mill）**：类似于现代的算术单元，执行包括加法、乘法和除法在内的操作，并支持条件分支、循环及溢出异常处理。
- **微代码的形式**：机器中的一些操作实现类似现代微代码的功能。
- **程序、输入和输出数据通过穿孔卡片操作**：指令卡片包含操作码及操作数的地址，格式为三地址制（两个源操作数，一个目标操作数），全部存储于“存储器”中。
- **分支指令通过机械地改变指令卡片顺序实现**。
- 尽管只有部分零件曾被制造出来，但分析机的概念极具前瞻性，为现代计算机设计奠定了基础。

### 分析机的设计选择

巴贝奇在设计分析机时，做出了一些有趣的设计选择：

- **十进制系统**：由于存储依赖于机械齿轮，巴贝奇选择使用十进制表示数值，虽然他考虑过二进制和其他进制系统，但十进制更易于人类理解。
- **40位数字精度**：这相当于超过133位的二进制精度，这样的高精度是为了减少在使用浮点硬件时的误差。
- **机械放大技术**：为了解决机械运动传输中的噪声，巴贝奇使用了“锁定”或机械放大来增强信号。
- **快速的“预期进位”**：这是一种机械版的进位传播技术，类似于现代CMOS加法器中的跨越进位技术（也是继电器加法器中使用的技术）。

## 阿达·洛芙莱斯 (1815-1852)

阿达·洛芙莱斯是历史上首位程序员，她通过对巴贝奇分析机的理解，预见了计算机在数学之外的潜力：

- **翻译了意大利科学家梅纳布雷亚的讲座笔记**，这些笔记记录了巴贝奇的讲座内容。洛芙莱斯不仅翻译，还在笔记中加入了大量个人见解。
- **描述了第一个计算程序**，用于计算伯努利数的算法，尽管分析机未能建成，但洛芙莱斯的设计证明了其可行性。
- **预见了计算机的更广泛用途**，她认为计算机不仅仅用于表格计算，还可以被用于更复杂的智能任务，并对计算机模拟人类思维表现出浓厚兴趣。

## 早期可编程计算器

在20世纪上半叶，模拟计算由于价格较低而更为流行，而数字计算机由于昂贵的硬件成本，在40年代之前难以普及。然而，从30年代末至40年代，一些可编程数字计算器开始出现：

- **Atanasoff线性方程求解器（1939年）**
- **Zuse Z3（1941年）**
- **哈佛Mark I（1944年）**
- **ENIAC（1946年）**

这些可编程数字计算器是现代计算机的前身，它们标志着从机械计算到电子数字计算的过渡，极大地推动了计算机科学的发展。

## Atanasoff-Berry线性方程求解器（1939年）

Atanasoff-Berry线性方程求解器（ABC）是为求解多达29个线性方程组而设计的定点函数计算器。该计算器具有以下特点：

- **数字二进制算术**：使用50位定点数字进行运算。
- **动态存储器**：通过电容器旋转鼓实现数据存储。
- **真空管逻辑**：用于处理计算任务。
  

在1973年的专利纠纷中，Atanasoff被正式认可为**自动电子数字计算机的发明者**，这一荣誉源于他与Eckert和Mauchly（ENIAC发明者）的专利争议。

## Zuse Z3（1941年）

Zuse Z3是由康拉德·祖泽在二战期间德国设计制造的早期电子计算机。它的主要特点包括：

- **2000个继电器**构成的机械系统。
- 支持**浮点算术运算**，能够处理极端数值（如正负无穷大），尽管其硬件对某些情况并没有明确定义。
- **64字存储器**，每字64位。
- **两级流水线**设计，包括取指和执行，外加回写阶段。
- 没有**条件分支**指令，程序通过纸带输入。

Zuse Z3是世界上**第一台可编程的自动计算机**，其设计为后来计算机的发展奠定了基础。

## 哈佛Mark I（1944年）

哈佛Mark I是由哈佛大学的Howard Aiken提出并由IBM资助建造的计算机。它的特点包括：

- 主要是**机械式**设计，带有一些电气控制的继电器和齿轮。
- 重达5吨，包含**750,000个部件**。
- 存储72个数字，每个数字有23个十进制位。
- 运算速度：加法0.3秒，乘法6秒，除法15秒，三角函数>1分钟。
- 使用**两地址制**指令集，输入通过纸带操作。
- 能够自动运行长程序，通过将纸带粘贴在一起实现程序循环。
- 无条件分支指令。
  

虽然Mark I提到了巴贝奇的分析机，但其能力仍然比巴贝奇的设计有所局限。

### ENIAC（1946年）

ENIAC是**第一台电子通用计算机**，由Eckert和Mauchly在第二次世界大战期间为美国陆军设计，以计算炮击表格。其主要特点包括：

- 使用了**17,468个真空管**。
- 重达30吨，面积达到1800平方英尺，功率消耗高达**150千瓦**。
- 具有**条件分支指令**，使得程序流程控制更加灵活。
- 编程通过**插线板**和开关完成，耗时较长。
- **纯电子指令提取和执行**，速度极快——例如，10位数乘法操作仅需2.8毫秒。
- ENIAC由于庞大的真空管数量，故障频发，平均每5天就会发生一次故障。

尽管ENIAC面临许多挑战，但它在速度上比Mark I快了2000倍，极大推动了电子计算机的进步。

![image-20240906093708065]({{ site.baseurl }}/docs/assets/image-20240906093708065.png)

## EDVAC

ENIAC团队开始讨论**存储程序**的概念，以加速编程并简化机器设计。约翰·冯·诺依曼在宾夕法尼亚大学担任顾问，并于1945年6月撰写了**EDVAC第一草案**，引发了许多机构对存储程序概念的兴趣。然而，冯·诺依曼的草案也破坏了专利的可能性，因为报告错误地将所有功劳归给了冯·诺依曼。Maurice Wilkes对该报告产生兴趣，并决定前往美国的计算机建设研讨会学习。

1948年，ENIAC进行了修改，允许其以存储程序模式运行，尽管由于I/O的限制，其运行速度比硬连线慢了6倍。然而，生产力的提升使得这一改变变得有意义。最终，EDVAC于1951年大致完成，尽管受到与大学的专利纠纷影响而推迟了进展。

## 曼彻斯特SSEM“Baby”（1948年）

曼彻斯特大学的团队建造了一台小规模的实验机器，展示了使用阴极射线管（CRT）作为计算机存储器的想法，以替代水银延迟线。这些**Williams-Kilburn管**是第一批**动态随机存取存储设备**。

主要特点：

- 32个32位字的存储，带有累加器和程序计数器。
- 该机器于1948年6月运行了世界上第一个**存储程序**。
- 促成了后来的曼彻斯特Mark-1的全尺寸机器开发，Mark-1引入了**变址寄存器**，并由Ferranti公司商业化。

## 剑桥EDSAC（1949年）

Maurice Wilkes从美国的研讨会返回剑桥后，开始构建一台基于**存储程序**的计算机EDSAC。EDSAC使用水银延迟线存储，初期能够存储最多1024个17位的单词（最初512个，外加延迟线中的1位填充）。主要特点包括：

- **二进制补码算术**。
- 具有**自修改代码**功能的累加器ISA，用于索引。
- David Wheeler发明了**子程序调用**（Wheeler跳跃），这是世界上第一个子程序调用，极大地增强了代码的可重用性。
- 英国第一个商业计算机LEO-I基于EDSAC开发，1951年开始为Lyons Electronic Office运行业务软件。

EDSAC-II（1958年）是第一个带有微程序控制单元的机器。

## 商用计算机：BINAC（1949年）和UNIVAC（1951年）

- Eckert和Mauchly在与宾夕法尼亚大学的专利权纠纷后离开，成立了Eckert-Mauchly计算机公司。
- 世界上第一台商用计算机是**BINAC**，具有**两个CPU**，相互进行检查。虽然BINAC从未成功交付给客户并工作，但它仍然是商用计算机发展的开端。
- 第二台商用计算机是**UNIVAC**，它使用了**水银延迟线存储**，每个单词包含**12个字母字符**，共1000个单词。UNIVAC因在1952年成功预测美国总统大选而闻名，最终共卖出46台，每台售价超过100万美元。尽管如此，它经常被错误地称为“IBM UNIVAC”。

## IBM 701（1952年）

- **IBM**的第一台商用科学计算机。
- 采用72个**William's Tubes**作为主存储器，每个管子存储1Kib的数据，总共**2048个36位字**。内存周期时间为**12微秒**。
- 使用**累加器ISA**，带有乘法器/除法器寄存器，支持**18位或36位的符号-幅值定点数**。
- 著名的误引语录：IBM创始人托马斯·沃森（Thomas Watson Sr/Jr）曾被误传说“我认为这个世界最多需要5台计算机”。实际上，他在股东会议上说的是“我们本来预计卖5台701机器，但结果接到了18台的订单”。

## IBM 650（1953年）

- **IBM 650**是第一台**大规模生产**的计算机，定位于低端系统，使用**鼓式存储器**和**数字串行ALU**（算术逻辑单元）。
- 这台计算机几乎生产了**2000台**，是当时广泛应用的商用计算机之一。

### IBM 650架构

IBM 650的架构图展示了其主要组件：
- **磁鼓存储器**，能够存储1000或2000个**10位十进制**单词。
- **有效指令**（包括下一个程序计数器）。
- **数字串行ALU**，用于处理20位累加器数据。

![image-20240906094505368]({{ site.baseurl }}/docs/assets/image-20240906094505368.png)

### IBM 650 指令集

- 地址和数据以**10位十进制**字长表示。
- 指令编码：
  - 两位操作码编码了**44条**基本指令，扩展到**97条**带有可选项的指令。
  - 四位数据地址。
  - 四位下一条指令的地址。
  - 程序员需要安排代码来**最小化磁鼓延迟**。
- 特殊指令可用于比较轨道上所有单词的值。

## 早期指令集

- 最早的指令集架构（ISA）非常简单，大多是**单地址累加器**式的机器，因为当时**高速电路**的成本非常高。
  - 这种设计基于早期的“计算器”模型。
- 随着软件需求的增加，对指令集架构的理解逐渐加深：
  - **索引寄存器**（如Kilburn和Mark-1）被引入，用于避免程序需要通过**自修改代码**来逐步处理数组。
  - 随时间推移，添加了更多的索引寄存器，并增加了对这些寄存器的操作。
  - 最终，发展为通用寄存器（GPR）和正交的指令集。

## IBM 360 架构

- 到20世纪60年代早期，IBM有多个**不兼容**的计算机系列：
  - 701 -> 7094
  - 650 -> 7074
  - 702 -> 7080
  - 1401 -> 7010
- 每个系统都有自己的一套：
  - **指令集**。
  - 输入输出系统及次级存储（如磁带、鼓式存储和磁盘）。
  - 汇编器、编译器、库等。
  - 不同的市场定位（如商业、科学、实时应用等）。

## IBM 360：设计前提（1964年）

- 由Amdahl、Blaauw和Brooks提出，IBM 360的设计理念如下：
  - 设计要能够支持**扩展**和未来的继任机器。
  - 提供一种通用方法来连接输入输出设备。
  - **整体性能**关注每月能够处理的问题数量，而不仅仅是每微秒处理的位数。
  - 机器要能够**自我监督**，无需人工干预。
  - 内置的硬件故障检查和定位功能可以帮助减少停机时间。
  - 系统的设计要便于组装冗余的输入输出设备、内存等，以实现**容错能力**。
  - 某些问题需要比36位更大的**浮点数**支持。

## IBM 360：通用寄存器（GPR）机器

- **处理器状态**：
  - 拥有**16个32位的通用寄存器**，可以用作索引或基地址寄存器。
  - 寄存器0有一些特殊的属性。
  - 4个64位浮点寄存器。
  - 程序状态字（PSW）。
  - **条件码**、控制标志。
- **32位机器**，具有24位地址，但**没有指令包含24位地址**。
- **数据格式**：
  - 8位字节、16位半字、32位字、64位双字。
  - 这就是**为什么今天的字节长度为8位**。

### IBM 360：最初的实现

- **存储**：8K-512KB。
- **数据路径**：8位 -> 64位。
- **电路延迟**：每层30纳秒 -> 5纳秒。
- **本地存储**：主存 -> 晶体管寄存器。
- **控制存储**：只读微代码 -> 专用电路。
  

IBM 360的**指令集架构（ISA）**完全隐藏了各种型号之间的技术差异。

**里程碑**：它是**第一个便携式硬件-软件接口设计**的指令集。该架构经过少量修改后至今仍在使用！

## IBM 大型机的持续发展

- **z15**（2020年发布，采用14纳米工艺，拥有17层金属，芯片面积为696平方毫米）：
  - 每个芯片有12个核心，频率为5.2GHz。
  - 拥有超过88亿个晶体管。
  - **缓存层次**：
    - 1MB一级缓存，128MB二级缓存，1GB三级缓存。
    - **共享缓存**有很高的带宽和改进的硬件预取器。
  - **管道优化**：
    - SIMD优化，改进的分支预测。
    - 更大的指令调度窗口，更好的循环展开。

![image-20240906095222960]({{ site.baseurl }}/docs/assets/image-20240906095222960.png)

### 总结

- **计算机架构**不仅仅是指令集和RTL，还包括与硬件和软件交互的抽象层设计。
- 计算机架构受到**技术和应用**的影响，历史能为未来的设计提供有益的经验。
- 在并行计算的交叉路口，计算机科学面临**从顺序计算向并行计算的转变**。

